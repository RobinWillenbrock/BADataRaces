\documentclass[
%%%%% Styles and Sizes
%10pt,
%11pt,
%12pt,
fancyheadings, % headings with seplines and logo
%
%%%%% Printing, Color and Binding
%a4paper, 
%a5paper,
%twoside, % single sided printout
%oneside, % duplex printout (default)
%% binding correction is used to compensate for the paper lost during binding
%% of the document
%BCOR=0.7cm, % binding correction
%nobcorignoretitle, % do not ignore BCOR for title page
%% the following two options only concern the graphics included by the document
%% class
%grayscaletitle, % keep the title in grayscale
%grayscalebody, % keep the rest of the document in grayscale
%
%%%%% expert options: your mileage may vary
%baseclass=..., % special option to use a different document baseclass
]{stsreprt}

% Information for the Titlepage
\author{Robin Willenbrock}
\title{Static Detection of Data Races in Interrupt-Driven Software Using Reduced Inter-Procedural Control Flow Graphs}
\date{\today}
\subject{Bachelor Thesis}
\professor{}
\advisor{Ulrike Engeln}

\usepackage[utf8]{inputenc}

% Font and Fontencoding Magic
% FAQ: 
% http://tex.stackexchange.com/questions/664/why-should-i-use-usepackaget1fontenc
% http://en.wikipedia.org/wiki/Computer_Modern
% http://tex.stackexchange.com/questions/1390/latin-modern-vs-cm-super
\usepackage[T1]{fontenc}
\usepackage{lmodern}
%\usepackage{fix-cm}

\begin{document}
\frontmatter
\maketitle
\tableofcontents
\listoffigures{}
\mainmatter{
\chapter{Introduction}



\chapter{Background}

\section{Interrupt-Driven Systems}
An interrupt-driven system is an architectur where the flow of the execution is changed by unpredictable events in the system also known as interrupts. Interrupts can be caused by hardware devices, software conditions or external signals forcing the proscessor to suspend the current task to execute an interrupt handler or interrupt service routine(ISR). Interrupt-driven systems are used in real-time operating systems, embedded systems and generally in systems where timely responses are nessesary \cite{wang2020}.

The management of the interrupts to keep the fast responsivness of the system is the challenging part of an interrupt-driven system. Interrupts occur unpredictable so you have to consider every execution flow. To ensure the execution of critical interrupts, interrupts are often prioritized, so higher priority events can interrupt lower ones and get handled immediatly. When handling an interrupt the current state of the processos is saved and the context is switched to the ISR \cite{wang2020}.

There are different types of interrupts based on the source they come from. There are Hardware interrupts, software interrupts and external interrupts. Each interrupt has different mechnisms and priorities, which influence the behavior of the system to the interrupt \cite{burns2009}.

The unpredictivness and asynchronous nature of the interrupts bring a lot of challenges in designing and implementing an interrupt-driven system. One of the biggest challenges is the correct handling of high-priority interrupts without delaying them substantually. Which needs an sophisticated scheduling and prioritization mechanism. The execution of main programm and ISR needs to be handled properly to ensure data intergrity. Furthermore, handling context switches, preserving system state and avoiding deadlocks complitcate the development of an interrupt-driven system \cite{labrosse2002}.


\section{Reduced Inter-Procedural Control Flow Graphs (RICFG)}
Control Flow Graphs (CFG) are representations of all possible path through a programm or a function during its execution. An Inter-Procedural Control Flow Graph (ICFG) adds possible edges between multiple programms or functions to also show possible control flows between those. A Reduced Inter-Procedural Control Flow Graph (RICFG) is an optimized version of the ICFG which simplifys the the graph to only the necessary informations needed for the analysis \cite{engler2003}.


A Control Flow Graph (CFG) is a representation of all paths that might be traversed through a program during its execution. In the context of inter-procedural analysis, an Inter-Procedural Control Flow Graph (ICFG) extends this concept by incorporating the control flow between different procedures or functions in a program. Reduced Inter-Procedural Control Flow Graphs (RIPCFG) are optimized versions of ICFGs, designed to simplify the analysis while preserving essential information \cite{engler2003}.

There are multiple techniques to reduce the graph, such as node merging, edge contraction and eliminaition of non-important nodes, without losing any informations required for the analysis and to reduce the complexity of the RICFG. The reduction of the ICFG makes the analysis of large and complex software a lot more efficient. By minimizing the amount of data but retaining enough detail, RICFG are great to use for static analysis of data races. 

RIPCFGs utilize various techniques such as node merging, edge contraction, and the elimination of non-essential nodes to reduce the complexity of the graph without losing critical control flow information. These reduction techniques make it feasible to analyze large and complex software systems, which would be computationally prohibitive with full ICFGs. By retaining enough detail, RIPCFGs facilitate accurate static analysis, including data flow analysis, control flow analysis, and the detection of potential data races and other concurrency issues. The reduced size and complexity result in more efficient analysis algorithms, enabling faster detection and resolution of issues in the software \cite{wang2020}.

\subsection{Techniques for Constructing RICFGs}

There are several techniques to construct a RICFG. Node merging is combining nodes that represent redundant control flow paths, to reduce the number of nodes in the graph. Edge contraction is simplifying the graph by reducing the amount of edges between nodes. It collapses edges, that do not significally affect the control flow of the graph. The elimination of nodes is the main tool used in this work to reduce the CFG. Eliminating nodes, which do not carry any essential information for the applied data analysis significally reduces the amount of data the algorithm has to analyze. Overall these techniques enhance the scalability of the static analysis and make it more practical to analyze more complex data \cite{muchnick1997}.

Several techniques are employed to construct RIPCFGs effectively. Node merging involves combining nodes that represent similar or redundant control flow paths, reducing the overall number of nodes in the graph. Edge contraction simplifies the graph by collapsing edges that do not significantly affect the control flow, thereby minimizing the number of connections between nodes. The elimination of non-essential nodes focuses on removing nodes that do not contribute to the primary control flow, such as nodes representing trivial or inline functions. These techniques collectively enhance the scalability and efficiency of static analysis, making it practical to analyze complex software systems \cite{muchnick1997}.

\subsection{Applications of RIPCFGs}

RIPCFGs are widely used in various static analysis applications, including data flow analysis, control flow analysis, and the detection of concurrency issues such as data races and deadlocks. By providing a simplified yet accurate representation of the program's control flow, RIPCFGs enable efficient analysis of large codebases, facilitating the identification and resolution of potential issues early in the development process. Additionally, RIPCFGs are instrumental in optimizing compilers, where they assist in optimizing code by identifying redundant or inefficient paths and enabling more effective code generation strategies \cite{muchnick1997}.

\section{Data Races}

Data races can occur when two or more functions or threads access a shared resource concurrently and also one of those accesses has to be a write opperation. This can lead to unpredictable behavior and errors in the system. This makes the detection of data races a critical aspect of concurrent programming.

Data races occur when two or more threads access shared data concurrently, and at least one of the accesses is a write. This condition can lead to unpredictable and erroneous behavior, making the detection and resolution of data races a critical aspect of concurrent programming \cite{flanagan2009}.

Without proper synchronization a system with multiple threads or functions which use shared data lead to data races. The outcome of a program with data races is non-deterministic. The order of execution of operations can vary, leading to not reproducable or hard-to-reproduce bugs. 


In systems where multiple threads execute without proper synchronization, data races arise from conflicting operations on shared data. The outcome of a program with data races is non-deterministic, as the order of execution and interleaving of operations can vary, leading to inconsistent results and hard-to-reproduce bugs.

\subsection{Types of Data Races}
There are primarily two types of data races. Two write operations lead to unpredictable data corruption since the value of the shared resource depends on the order of execution of the two write operations. Data races with one read operation and one write operation can cause faulse programm behavior since the data that is read can be inconsistent due to the possibility of the concurrent write operation.


There are primarily two types of data races. Write-write races occur when multiple threads write to the same variable simultaneously, potentially causing data corruption as the final value of the variable depends on the order of writes, which is non-deterministic. Read-write races occur when one thread reads a variable while another thread writes to it concurrently, leading to the possibility of reading stale or inconsistent data, which can cause erroneous program behavior \cite{flanagan2009}.

\subsection{Detection Techniques}

Static analysis examines the code without executing it. Static analysis tools analyze the source code to detect data races by simulating different execution paths of the program. It can identify potential data races by examining the control flow  and data dependencies of shared data in the code. This enables early detection of possible issues.

Various static and dynamic analysis techniques are used to detect data races. Static analysis involves examining the code without executing it. Tools such as RacerX \cite{engler2003} analyze the program's source code to detect race conditions and deadlocks by simulating different execution paths. Static analysis can identify potential data races by examining the control flow and data dependencies in the code, enabling early detection and resolution of issues.

On the other hand there are dynamic analysis tools which monitors the program during execution to identify possible data races.

Dynamic analysis, on the other hand, monitors the program during execution to identify potential race conditions. FastTrack \cite{flanagan2009} is a dynamic analysis tool that efficiently detects data races by maintaining a happens-before relationship among the threads' operations and checking for violations. Dynamic analysis provides a runtime perspective, capturing actual execution scenarios and detecting data races that may not be evident through static analysis alone.

Hybrid techniques combine static and dynamic analysis to leverage the strengths of both approaches. Static analysis can identify potential race conditions, which can then be confirmed or refuted by dynamic analysis during actual program execution. This approach allows for comprehensive detection and resolution of data races, ensuring both theoretical and practical coverage of potential issues.

\subsection{Implications of Data Races}

The presence of data races in a program can lead to several critical issues. The outcome of a program with data races is non-deterministic, making it difficult to reproduce and debug errors. Concurrent writes to shared data without proper synchronization can lead to data corruption, resulting in incorrect program behavior and potentially causing system crashes. Furthermore, data races can be exploited by malicious actors to create security vulnerabilities. Inconsistent data states can be manipulated to bypass security checks or corrupt sensitive data, posing significant risks to system integrity and security \cite{adve1996}.

\subsection{Strategies for Preventing Data Races}

Preventing data races requires careful design and implementation of concurrent programs. One effective strategy is to use proper synchronization mechanisms, such as mutexes, semaphores, and condition variables, to control access to shared data. These mechanisms ensure that only one thread can access the shared data at a time, preventing conflicting operations. Avoiding shared mutable state is another effective strategy, where threads operate on local copies of data instead of shared data, reducing the potential for conflicts. Designing thread-safe data structures and algorithms that inherently manage concurrent access also helps prevent data races, ensuring reliable and predictable program behavior \cite{herlihy2008}.

\section{Static Detection of Data Races in Interrupt-Driven Systems}

In interrupt-driven systems, the asynchronous nature of interrupts and the concurrent execution of ISRs and the main program introduce significant challenges in ensuring data consistency and detecting data races. Static analysis techniques, particularly those using RIPCFGs, offer a promising approach to identifying potential data races without the need for exhaustive testing or runtime monitoring \cite{wang2020}.

The approach involves constructing RIPCFGs for the program, including both the main code and ISRs, capturing the control flow and potential interactions between them. By analyzing the RIPCFGs, paths where shared data is accessed concurrently without proper synchronization can be identified, indicating potential data races. Integrating the static analysis tool with the development workflow enables continuous detection and resolution of data races during the software development lifecycle, improving the reliability and correctness of interrupt-driven systems \cite{wang2020}.

\subsection{Methodology for Static Detection}

The methodology for static detection of data races in interrupt-driven systems involves several key steps. First, the RIPCFGs are constructed for the entire program, including the main code and ISRs. This involves analyzing the control flow and identifying points where the main program and ISRs interact with shared data. Next, the RIPCFGs are analyzed to identify potential race conditions, focusing on paths where concurrent access to shared data may occur without proper synchronization. Finally, the analysis results are integrated with the development workflow, allowing developers to address identified race conditions early in the development process. This methodology ensures comprehensive coverage of potential race conditions and facilitates timely resolution of issues \cite{wang2020}.





\chapter{Implementation}
3,5 Wochen
\chapter{Evaluation}
1,5 Woche 
\chapter{Conclusion}
Indroduction+Conclusion und Allgemeine Überarbeitung 0,5 Woche
1 Wochen Korrekturlesen und Einarbeitung
=9 Wochen bei Vollarbeitszeit an BE
\appendix
}
\backmatter{}
\chapter{Bibliography}
Lightweight Data Race Detection for Production by Swarnendu Biswas, Man Cao, Minjia Zhang, Michael D. Bond, Benjamin P. Wood


A Deployable Sampling Strategy for Data Race Detection by Yan Cai1, Jian Zhang, Lingwei Cao, and Jian Liu
\begin{thebibliography}{9}
	\bibitem{wang2020}
	Wang, Y., Gao, F., Wang, L., Yu, T., Zhao, J., \& Li, X. (2020). Automatic Detection, Validation, and Repair of Race Conditions in Interrupt-Driven Embedded Software. IEEE Transactions on Software Engineering.
	
	\bibitem{engler2003}
	Engler, D., \& Ashcraft, K. (2003). RacerX: Effective, Static Detection of Race Conditions and Deadlocks. ACM SIGOPS Operating Systems Review.
	
	\bibitem{flanagan2009}
	Flanagan, C., \& Freund, S. N. (2009). FastTrack: Efficient and Precise Dynamic Race Detection. ACM SIGPLAN Notices.
	
	\bibitem{burns2009}
	Burns, A., \& Wellings, A. (2009). Real-Time Systems and Programming Languages. Addison-Wesley.
	
	\bibitem{labrosse2002}
	Labrosse, J. J. (2002). MicroC/OS-II: The Real-Time Kernel. CMP Books.
	
	\bibitem{muchnick1997}
	Muchnick, S. S. (1997). Advanced Compiler Design and Implementation. Morgan Kaufmann.
	
	\bibitem{adve1996}
	Adve, S. V., \& Gharachorloo, K. (1996). Shared Memory Consistency Models: A Tutorial. IEEE Computer.
	
	\bibitem{herlihy2008}
	Herlihy, M., \& Shavit, N. (2008). The Art of Multiprocessor Programming. Morgan Kaufmann.
\end{thebibliography}

\end{document}